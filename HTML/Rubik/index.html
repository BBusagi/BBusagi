<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rubik 3D 3x3</title>
    <style>
      :root {
        --bg: #2b2f36;
        --fg: #e6edf3;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: radial-gradient(1200px 800px at 20% 10%, #3a3f48, #2b2f36 60%);
        color: var(--fg);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      #app {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      .hint {
        position: fixed;
        left: 16px;
        bottom: 12px;
        font-size: 12px;
        opacity: 0.7;
        user-select: none;
      }
      #reset-btn {
        position: fixed;
        left: 16px;
        top: 16px;
        padding: 8px 14px;
        border-radius: 10px;
        border: 1px solid #3b4250;
        background: #3a404b;
        color: #eef2f7;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      }
      #reset-btn:hover {
        background: #4a5160;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <button id="reset-btn" type="button">重置</button>
    <div class="hint">点击小格切换：默认 → O → X，拖动旋转，滚轮缩放</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      const app = document.getElementById("app");

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0b0f14, 6, 18);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(5, 4, 6);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      app.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const key = new THREE.DirectionalLight(0xffffff, 0.9);
      key.position.set(5, 6, 3);
      scene.add(key);

      const fill = new THREE.DirectionalLight(0xffffff, 0.4);
      fill.position.set(-5, -2, -4);
      scene.add(fill);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;

      const FACE = {
        U: "#ffffff",
        D: "#ffd500",
        F: "#00a651",
        B: "#0047ab",
        L: "#ff5800",
        R: "#c41e3a",
      };

      const FACE_STICKERS = {
        U: [FACE.U, FACE.U, FACE.U, FACE.U, FACE.U, FACE.U, FACE.U, FACE.U, FACE.U],
        D: [FACE.D, FACE.D, FACE.D, FACE.D, FACE.D, FACE.D, FACE.D, FACE.D, FACE.D],
        F: [FACE.F, FACE.F, FACE.F, FACE.F, FACE.F, FACE.F, FACE.F, FACE.F, FACE.F],
        B: [FACE.B, FACE.B, FACE.B, FACE.B, FACE.B, FACE.B, FACE.B, FACE.B, FACE.B],
        L: [FACE.L, FACE.L, FACE.L, FACE.L, FACE.L, FACE.L, FACE.L, FACE.L, FACE.L],
        R: [FACE.R, FACE.R, FACE.R, FACE.R, FACE.R, FACE.R, FACE.R, FACE.R, FACE.R],
      };

      const TEX_SIZE = 512;
      const TEX_PAD = 36;
      const TEX_GAP = 18;
      const TEX_CELL = (TEX_SIZE - TEX_PAD * 2 - TEX_GAP * 2) / 3;
      const FACE_ORDER = ["R", "L", "U", "D", "F", "B"];

      const FACE_STATE = {
        U: Array(9).fill(0),
        D: Array(9).fill(0),
        F: Array(9).fill(0),
        B: Array(9).fill(0),
        L: Array(9).fill(0),
        R: Array(9).fill(0),
      };

      const CORNER_GROUPS = [
        [
          ["U", 8],
          ["R", 0],
          ["F", 2],
        ],
        [
          ["U", 6],
          ["L", 2],
          ["F", 0],
        ],
        [
          ["U", 0],
          ["L", 0],
          ["B", 2],
        ],
        [
          ["U", 2],
          ["R", 2],
          ["B", 0],
        ],
        [
          ["D", 2],
          ["R", 6],
          ["F", 8],
        ],
        [
          ["D", 0],
          ["L", 8],
          ["F", 6],
        ],
        [
          ["D", 6],
          ["L", 6],
          ["B", 8],
        ],
        [
          ["D", 8],
          ["R", 8],
          ["B", 6],
        ],
      ];

      const EDGE_GROUPS = [
        [
          ["U", 7],
          ["F", 1],
        ],
        [
          ["U", 5],
          ["R", 1],
        ],
        [
          ["U", 1],
          ["B", 1],
        ],
        [
          ["U", 3],
          ["L", 1],
        ],
        [
          ["D", 1],
          ["F", 7],
        ],
        [
          ["D", 5],
          ["R", 7],
        ],
        [
          ["D", 7],
          ["B", 7],
        ],
        [
          ["D", 3],
          ["L", 7],
        ],
        [
          ["F", 5],
          ["R", 3],
        ],
        [
          ["F", 3],
          ["L", 5],
        ],
        [
          ["B", 3],
          ["R", 5],
        ],
        [
          ["B", 5],
          ["L", 3],
        ],
      ];

      function buildLinkMap(groups) {
        const map = new Map();
        for (const group of groups) {
          for (const [faceKey, idx] of group) {
            map.set(`${faceKey}-${idx}`, group);
          }
        }
        return map;
      }

      const LINK_MAP = buildLinkMap([...CORNER_GROUPS, ...EDGE_GROUPS]);

      function roundRect(ctx, x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      function drawFace(ctx, faceKey) {
        ctx.clearRect(0, 0, TEX_SIZE, TEX_SIZE);
        ctx.fillStyle = "#1b2230";
        ctx.fillRect(0, 0, TEX_SIZE, TEX_SIZE);

        ctx.fillStyle = "#2a2f38";
        roundRect(ctx, TEX_PAD, TEX_PAD, TEX_SIZE - TEX_PAD * 2, TEX_SIZE - TEX_PAD * 2, 28);
        ctx.fill();

        for (let y = 0; y < 3; y++) {
          for (let x = 0; x < 3; x++) {
            const cx = TEX_PAD + x * (TEX_CELL + TEX_GAP);
            const cy = TEX_PAD + y * (TEX_CELL + TEX_GAP);
            const idx = y * 3 + x;
            ctx.fillStyle = FACE_STICKERS[faceKey][idx];
            roundRect(ctx, cx, cy, TEX_CELL, TEX_CELL, 18);
            ctx.fill();
            ctx.strokeStyle = "#1c2330";
            ctx.lineWidth = 6;
            ctx.stroke();

            const state = FACE_STATE[faceKey][idx];
            if (state === 1) {
              const r = TEX_CELL * 0.32;
              const ox = cx + TEX_CELL / 2;
              const oy = cy + TEX_CELL / 2;
              ctx.strokeStyle = "#7dff9b";
              ctx.lineWidth = 10;
              ctx.beginPath();
              ctx.arc(ox, oy, r, 0, Math.PI * 2);
              ctx.stroke();
            } else if (state === 2) {
              const margin = TEX_CELL * 0.28;
              ctx.strokeStyle = "#ff7a8c";
              ctx.lineWidth = 10;
              ctx.beginPath();
              ctx.moveTo(cx + margin, cy + margin);
              ctx.lineTo(cx + TEX_CELL - margin, cy + TEX_CELL - margin);
              ctx.moveTo(cx + TEX_CELL - margin, cy + margin);
              ctx.lineTo(cx + margin, cy + TEX_CELL - margin);
              ctx.stroke();
            }
          }
        }
      }

      function createFaceTexture(faceKey) {
        const canvas = document.createElement("canvas");
        canvas.width = TEX_SIZE;
        canvas.height = TEX_SIZE;
        const ctx = canvas.getContext("2d");
        drawFace(ctx, faceKey);
        const texture = new THREE.CanvasTexture(canvas);
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture.needsUpdate = true;
        return { canvas, ctx, texture, faceKey };
      }

      function redrawFaces(faceKeys) {
        for (const key of faceKeys) {
          const faceTex = faceTextures[key];
          drawFace(faceTex.ctx, key);
          faceTex.texture.needsUpdate = true;
        }
      }

      const faceTextures = {};
      const materials = FACE_ORDER.map((key) => {
        const faceTex = createFaceTexture(key);
        faceTextures[key] = faceTex;
        return new THREE.MeshStandardMaterial({ map: faceTex.texture });
      });

      const cube = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), materials);
      cube.castShadow = true;
      cube.receiveShadow = true;
      scene.add(cube);

      const rim = new THREE.Mesh(
        new THREE.BoxGeometry(3.04, 3.04, 3.04),
        new THREE.MeshStandardMaterial({
          color: 0x0b0f14,
          metalness: 0.05,
          roughness: 0.8,
          opacity: 0.35,
          transparent: true,
        })
      );
      scene.add(rim);

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function getStickerIndexFromUV(uv) {
        const px = uv.x * TEX_SIZE;
        const py = (1 - uv.y) * TEX_SIZE;
        for (let y = 0; y < 3; y++) {
          for (let x = 0; x < 3; x++) {
            const cx = TEX_PAD + x * (TEX_CELL + TEX_GAP);
            const cy = TEX_PAD + y * (TEX_CELL + TEX_GAP);
            if (px >= cx && px <= cx + TEX_CELL && py >= cy && py <= cy + TEX_CELL) {
              return y * 3 + x;
            }
          }
        }
        return null;
      }

      function onPointerDown(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObject(cube, false);
        if (!hits.length) return;
        const hit = hits[0];
        if (!hit.uv) return;
        const faceIndex = hit.faceIndex ?? -1;
        if (faceIndex < 0) return;
        const side = Math.floor(faceIndex / 2);
        const faceKey = FACE_ORDER[side];
        const idx = getStickerIndexFromUV(hit.uv);
        if (idx === null) return;

        const state = FACE_STATE[faceKey][idx];
        const nextState = (state + 1) % 3;
        const group = LINK_MAP.get(`${faceKey}-${idx}`);
        if (group) {
          const facesToRedraw = new Set();
          for (const [f, i] of group) {
            FACE_STATE[f][i] = nextState;
            facesToRedraw.add(f);
          }
          redrawFaces(facesToRedraw);
        } else {
          FACE_STATE[faceKey][idx] = nextState;
          redrawFaces(new Set([faceKey]));
        }
      }

      renderer.domElement.addEventListener("pointerdown", onPointerDown);
      const resetBtn = document.getElementById("reset-btn");
      resetBtn.addEventListener("click", () => {
        for (const key of Object.keys(FACE_STATE)) {
          FACE_STATE[key].fill(0);
        }
        redrawFaces(new Set(Object.keys(faceTextures)));
      });

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener("resize", onResize);

      function animate() {
        requestAnimationFrame(animate);
        rim.rotation.copy(cube.rotation);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
